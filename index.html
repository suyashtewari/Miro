<!DOCTYPE html>
<html>
  <head>
    <!-- change this for each update to Miro -->
    <title>Miro 0.0.2</title>
    <style>
      /* Reset default styles */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      .gameContainer {
        display: none;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }

      /* Show the container with a fade-in animation */
      .gameContainer.show {
        display: block;
        opacity: 1;
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: Arial, sans-serif;
        background-color: #f0efeb;
      }

      header {
        color: #b9605c;
        padding: 10px;
        text-align: center;
        margin-bottom: 20px;
      }

      main {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        width: 100%;
        max-width: 800px;
        padding: 20px;
        background-color: #fff;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      }

      .maze-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 20px;
      }

      .stats {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
      }

      .stat {
        display: flex;
        align-items: center;
        margin-right: 20px;
        /* Add margin between stat elements */
      }

      .stat-label {
        font-size: 18px;
        font-weight: bold;
        margin-right: 5px;
        color: #b9605c;
      }

      .stat-value {
        font-size: 18px;
        color: #000;
      }

      .slider-container {
        margin-top: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .slider-label {
        margin-right: 5px;
        font-weight: bold;
        color: #b9605c;
      }

      input[type="range"] {
        -webkit-appearance: none;
        width: 200px;
        height: 8px;
        border-radius: 4px;
        background-color: #d3908d;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: #b9605c;
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #f0efeb;
        cursor: pointer;
        border-radius: 50%;
      }

      input[type="range"]:hover {
        opacity: 1;
      }

      canvas {
        border: 3px solid #d3908d;
        background-color: #f0efeb;
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: -o-crisp-edges;
        image-rendering: pixelated;
        -ms-interpolation-mode: nearest-neighbor;
        width: 100%;
        max-width: 400px;
      }

      footer {
        color: #000;
        padding: 10px;
        text-align: center;
        margin-top: 20px;
      }

      footer p {
        margin: 0;
      }

      #startButton {
        background-color: #b9605c;
        color: #fff;
        border: none;
        padding: 10px 20px;
        font-size: 18px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      #startButton:hover {
        background-color: #d3908d;
      }

      #downloadButton {
        background-color: #b9605c;
        color: #fff;
        border: none;
        padding: 10px 20px;
        font-size: 18px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      #downloadButton:hover {
        background-color: #d3908d;
      }
    </style>
  </head>

  <body>
    <audio id="sound1" src="menuselect.wav" preload="auto"></audio>
    <div id="startButtonContainer">
      <button
        id="startButton"
        onclick="document.getElementById('sound1').play()"
      >
        Miro
      </button>
    </div>
    <div id="mazeContainer" class="gameContainer">
      <header>
        <h1>Miro</h1>
        <br />
        <button id="downloadButton" onclick="soundEffect('menuselect.wav')">
          Download Data
        </button>
      </header>
      <main>
        <div class="maze-container">
          <canvas
            id="mazeCanvas"
            width="800"
            height="800"
            class="maze"
          ></canvas>
        </div>

        <div class="stats">
          <div class="stat">
            <div class="stat-label">Moves:</div>
            <div id="moveCount" class="stat-value">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Time:</div>
            <div id="stopwatch" class="stat-value">0:00</div>
          </div>
          <div class="stat">
            <div class="stat-label">Mazes Finished:</div>
            <div id="mazesFinishedCount" class="stat-value">0</div>
          </div>
        </div>

        <div class="slider-container">
          <div class="slider-label">Wall Probability:</div>
          <input
            type="range"
            id="wallProbabilitySlider"
            min="0"
            max="1"
            step="0.01"
            value="0.5"
            onchange="soundEffect('menuselect.wav');updateWallProbability(this.value);"
          />
          <div id="wallProbabilityValue" class="stat-value">0.5</div>
        </div>
      </main>
    </div>

    <footer>
      <p>&copy; 2023 Miro. All rights reserved.</p>
    </footer>

    <script>
      const startButtonContainer = document.getElementById(
        "startButtonContainer"
      );
      const mazeContainer = document.getElementById("mazeContainer");
      const downloadButton = document.getElementById("downloadButton");
      downloadButton.addEventListener("click", downloadData);

      startButton.addEventListener("click", () => {
        soundEffect("menuselect.wav");
        startButtonContainer.style.display = "none";
        mazeContainer.classList.add("show");
        initializeGame();
      });

      const canvas = document.getElementById("mazeCanvas");
      const context = canvas.getContext("2d");
      const cellSize = 50;
      const mazeSize = 15;
      let maze, playerX, playerY;
      let moveCount = 0;
      let stopwatchInterval;
      let stopwatchSeconds = 0;
      let wallProbability = 0.5; // Initial wall probability value
      let mazesFinishedCount = 0;

      function downloadData() {
        // Create a CSV string with the header
        let csv = "Maze Number,Moves,Time\n";

        // Iterate through each completed maze
        for (let i = 1; i <= mazesFinishedCount; i++) {
          const movesValue = moveCounts[i];
          const timeValue = timeValues[i];

          // Append the maze number, moves, and time to the CSV string
          csv += `${i},${movesValue},${timeValue}\n`;
        }

        // Create a Blob object with the CSV string
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });

        // Create a temporary anchor element to trigger the download
        const link = document.createElement("a");
        if (link.download !== undefined) {
          // Set the anchor's attributes
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", "maze_data.csv");

          // Append the anchor to the body and trigger the download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        } else {
          alert("Your browser does not support downloading files.");
        }
      }

      let moveCounts = [];
      let timeValues = [];

      function generateMaze() {
        const maze = [];
        for (let i = 0; i < mazeSize; i++) {
          maze[i] = [];
          for (let j = 0; j < mazeSize; j++) {
            maze[i][j] = 1;
          }
        }

        function generatePaths(x, y) {
          const directions = [
            [-2, 0],
            [2, 0],
            [0, -2],
            [0, 2],
          ];
          directions.sort(() => Math.random() - 0.5);

          for (let i = 0; i < directions.length; i++) {
            const [dx, dy] = directions[i];
            const nx = x + dx;
            const ny = y + dy;

            if (
              nx >= 0 &&
              nx < mazeSize &&
              ny >= 0 &&
              ny < mazeSize &&
              maze[nx][ny] === 1
            ) {
              maze[x + dx / 2][y + dy / 2] = 0;
              maze[nx][ny] = 0;
              generatePaths(nx, ny);
            }
          }
        }

        const startX = Math.floor((Math.random() * (mazeSize - 1)) / 2) * 2 + 1;
        const startY = Math.floor((Math.random() * (mazeSize - 1)) / 2) * 2 + 1;
        generatePaths(startX, startY);

        let endX, endY;
        do {
          endX = Math.floor((Math.random() * (mazeSize - 1)) / 2) * 2 + 1;
          endY = Math.floor((Math.random() * (mazeSize - 1)) / 2) * 2 + 1;
        } while (
          maze[endX][endY] === 1 ||
          (startX === endX && startY === endY)
        );

        return {
          maze,
          startX,
          startY,
          endX,
          endY,
        };
      }

      function drawMaze() {
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        context.clearRect(0, 0, canvasWidth, canvasHeight);

        const mazeWidth = mazeSize * cellSize;
        const mazeHeight = mazeSize * cellSize;

        const offsetX = (canvasWidth - mazeWidth) / 2;
        const offsetY = (canvasHeight - mazeHeight) / 2;

        for (let i = 0; i < mazeSize; i++) {
          for (let j = 0; j < mazeSize; j++) {
            const x = j * cellSize + offsetX;
            const y = i * cellSize + offsetY;

            if (
              maze.maze[i][j] === 1 ||
              (maze.maze[i][j] === 0 && shouldAppearAsWall(i, j))
            ) {
              context.fillStyle = "#d3908d"; // Dark pastel pink for walls
            } else {
              context.fillStyle = "#f0efeb"; // Path color
            }
            context.fillRect(x, y, cellSize, cellSize);
          }
        }

        const playerXOffset = playerX + offsetX;
        const playerYOffset = playerY + offsetY;

        context.fillStyle = "#b9605c"; // Player color
        context.fillRect(playerXOffset, playerYOffset, cellSize, cellSize);

        const endXOffset = maze.endY * cellSize + offsetX;
        const endYOffset = maze.endX * cellSize + offsetY;

        context.fillStyle = "#fd6266"; // Endpoint color
        context.fillRect(endXOffset, endYOffset, cellSize, cellSize);
      }

      function shouldAppearAsWall(x, y) {
        return Math.random() < wallProbability;
      }

      function movePlayer(dx, dy) {
        const newX = playerX + dx;
        const newY = playerY + dy;

        if (
          newX >= 0 &&
          newX < mazeSize * cellSize &&
          newY >= 0 &&
          newY < mazeSize * cellSize
        ) {
          if (
            maze.maze[Math.floor(newY / cellSize)][
              Math.floor(newX / cellSize)
            ] === 0
          ) {
            soundEffect("validmovement.wav");
            playerX = newX;
            playerY = newY;
            drawMaze();
          } else {
            soundEffect("ES_Volleyball Hit 4 - SFX Producer.wav");
          }
          // Count attempted moves even if they are blocked by walls
          moveCount++;
          document.getElementById("moveCount").textContent = moveCount;

          if (
            playerX === maze.endY * cellSize &&
            playerY === maze.endX * cellSize
          ) {
            soundEffect("win_sound.mp3");
            clearInterval(stopwatchInterval);
            finishMaze();
            maze = generateMaze();
            playerX = maze.startY * cellSize;
            playerY = maze.startX * cellSize;
            moveCount = 0;
            document.getElementById("moveCount").textContent = moveCount;
            startStopwatch();
            drawMaze();
            const shortestPathLength = shortestPath(maze); // Calculate the length of the shortest path
            console.log("Shortest Path Length:", shortestPathLength);
          }
        }
      }

      function finishMaze() {
        mazesFinishedCount++;
        document.getElementById("mazesFinishedCount").textContent =
          mazesFinishedCount;
        const movesValue = moveCount;
        const timeValue = document.getElementById("stopwatch").textContent;
        moveCounts[mazesFinishedCount] = movesValue;
        timeValues[mazesFinishedCount] = timeValue;
      }

      function startStopwatch() {
        stopwatchSeconds = 0;
        clearInterval(stopwatchInterval);
        stopwatchInterval = setInterval(() => {
          stopwatchSeconds++;
          const minutes = Math.floor(stopwatchSeconds / 60);
          const seconds = stopwatchSeconds % 60;
          const timeString = `${minutes}:${seconds
            .toString()
            .padStart(2, "0")}`;
          document.getElementById("stopwatch").textContent = timeString;
        }, 1000);
      }

      function updateWallProbability(value) {
        wallProbability = parseFloat(value);
        document.getElementById("wallProbabilityValue").textContent =
          wallProbability;
        drawMaze();
      }

      function initializeGame() {
        maze = generateMaze();
        playerX = maze.startY * cellSize;
        playerY = maze.startX * cellSize;
        drawMaze();
        startStopwatch();
        const shortestPathLength = shortestPath(maze); // Calculate the length of the shortest path
        console.log("Shortest Path Length:", shortestPathLength);
      }

      function soundEffect(audio) {
        let soundEffect = new Audio(audio);
        soundEffect.volume = 0.4;
        soundEffect.play();
      }

      function shortestPath(maze) {
        const queue = [[maze.startX, maze.startY, 0]]; // Initialize the queue with the starting point and distance 0
        const visited = new Set(); // Keep track of visited cells

        while (queue.length > 0) {
          const [x, y, distance] = queue.shift(); // Dequeue the first element from the queue
          visited.add(`${x},${y}`); // Mark the cell as visited

          // Check if the current cell is the endpoint
          if (x === maze.endX && y === maze.endY) {
            return distance; // Return the distance if the endpoint is reached
          }

          // Get the neighboring cells
          const neighbors = [
            [x - 1, y],
            [x + 1, y],
            [x, y - 1],
            [x, y + 1],
          ];

          // Enqueue the neighboring cells if they are valid and not visited
          for (const [nx, ny] of neighbors) {
            if (
              nx >= 0 &&
              nx < mazeSize &&
              ny >= 0 &&
              ny < mazeSize &&
              maze.maze[nx][ny] === 0 &&
              !visited.has(`${nx},${ny}`)
            ) {
              queue.push([nx, ny, distance + 1]); // Enqueue the neighbor with an increased distance
              visited.add(`${nx},${ny}`); // Mark the neighbor as visited
            }
          }
        }

        return -1; // Return -1 if no path is found
      }

      document.addEventListener("keydown", function (event) {
        const key = event.key.toLowerCase();

        if (key === "w") {
          movePlayer(0, -cellSize);
        } else if (key === "a") {
          movePlayer(-cellSize, 0);
        } else if (key === "s") {
          movePlayer(0, cellSize);
        } else if (key === "d") {
          movePlayer(cellSize, 0);
        }
      });
    </script>
  </body>
</html>

<!DOCTYPE html>
<html>

<head>
    <title>Miro</title>
    <style>
        /* Reset default styles */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        .gameContainer {
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        /* Show the container with a fade-in animation */
        .gameContainer.show {
            display: block;
            opacity: 1;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            background-color: #f0efeb;
        }

        header {
            color: #b9605c;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }

        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%;
            max-width: 800px;
            padding: 20px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .maze-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .stat {
            display: flex;
            align-items: center;
            margin-right: 20px;
            /* Add margin between stat elements */
        }

        .stat-label {
            font-size: 18px;
            font-weight: bold;
            margin-right: 5px;
            color: #b9605c;
        }

        .stat-value {
            font-size: 18px;
            color: #000;
        }

        .slider-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slider-label {
            margin-right: 5px;
            font-weight: bold;
            color: #b9605c;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 200px;
            height: 8px;
            border-radius: 4px;
            background-color: #d3908d;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #b9605c;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #f0efeb;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        canvas {
            border: 3px solid #d3908d;
            background-color: #f0efeb;
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -o-crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
            width: 100%;
            max-width: 400px;
        }

        footer {
            color: #000;
            padding: 10px;
            text-align: center;
            margin-top: 20px;
        }

        footer p {
            margin:
            
            0;
        }

        #startButton {
  background-color: #b9605c;
  color: #fff;
  border: none;
  padding: 10px 20px;
  font-size: 18px;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s;
}

#startButton:hover {
  background-color: #d3908d;
}




    </style>
</head>

<body>
    <div id="startButtonContainer">
        <button id="startButton">Miro</button>
    </div>
    <div id="mazeContainer" class="gameContainer">
        <header>
            <h1>Miro</h1>
        </header>
        <main>
            <div class="maze-container">
                <canvas id="mazeCanvas" width="800" height="800" class="maze"></canvas>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-label">Moves:</div>
                    <div id="moveCount" class="stat-value">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Time:</div>
                    <div id="stopwatch" class="stat-value">0:00</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Mazes Finished:</div>
                    <div id="mazesFinishedCount" class="stat-value">0</div>
                </div>
            </div>

            <div class="slider-container">
                <div class="slider-label">Wall Probability:</div>
                <input type="range" id="wallProbabilitySlider" min="0" max="1" step="0.01" value="0.5"
                    onchange="updateWallProbability(this.value)" />
                <div id="wallProbabilityValue" class="stat-value">0.5</div>
            </div>
        </main>
    </div>

    <footer>
        <p>&copy; 2023 Miro. All rights reserved.</p>
    </footer>

    <script>

        const startButtonContainer = document.getElementById('startButtonContainer');
        const mazeContainer = document.getElementById('mazeContainer');

        startButton.addEventListener('click', () => {
            startButtonContainer.style.display = 'none';
            mazeContainer.classList.add('show');
        });
        
        const canvas = document.getElementById('mazeCanvas');
        const context = canvas.getContext('2d');
        const cellSize = 50;
        const mazeSize = 15;
        let maze, playerX, playerY;
        let moveCount = 0;
        let stopwatchInterval;
        let stopwatchSeconds = 0;
        let wallProbability = 0.5; // Initial wall probability value
        let mazesFinishedCount = 0;

        function generateMaze() {
            const maze = [];
            for (let i = 0; i < mazeSize; i++) {
                maze[i] = [];
                for (let j = 0; j < mazeSize; j++) {
                    maze[i][j] = 1;
                }
            }

            function generatePaths(x, y) {
                const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];
                directions.sort(() => Math.random() - 0.5);

                for (let i = 0; i < directions.length; i++) {
                    const [dx, dy] = directions[i];
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && maze[nx][ny] === 1) {
                        maze[x + dx / 2][y + dy / 2] = 0;
                        maze[nx][ny] = 0;
                        generatePaths(nx, ny);
                    }
                }
            }

            const startX = Math.floor(Math.random() * (mazeSize - 1) / 2) * 2 + 1;
            const startY = Math.floor(Math.random() * (mazeSize - 1) / 2) * 2 + 1;
            generatePaths(startX, startY);

            let endX, endY;
            do {
                endX = Math.floor(Math.random() * (mazeSize - 1) / 2) * 2 + 1;
                endY = Math.floor(Math.random() * (mazeSize - 1) / 2) * 2 + 1;
            } while (maze[endX][endY] === 1);

            return {
                maze,
                startX,
                startY,
                endX,
                endY
            };
        }

        function drawMaze() {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            context.clearRect(0, 0, canvasWidth, canvasHeight);

            const mazeWidth = mazeSize * cellSize;
            const mazeHeight = mazeSize * cellSize;

            const offsetX = (canvasWidth - mazeWidth) / 2;
            const offsetY = (canvasHeight - mazeHeight) / 2;

            for (let i = 0; i < mazeSize; i++) {
                for (let j = 0; j < mazeSize; j++) {
                    const x = j * cellSize + offsetX;
                    const y = i * cellSize + offsetY;

                    if (maze.maze[i][j] === 1 || (maze.maze[i][j] === 0 && shouldAppearAsWall(i, j))) {
                        context.fillStyle = "#d3908d"; // Dark pastel pink for walls
                    } else {
                        context.fillStyle = "#f0efeb"; // Path color
                    }
                    context.fillRect(x, y, cellSize, cellSize);
                }
            }

            const playerXOffset = playerX + offsetX;
            const playerYOffset = playerY + offsetY;

            context.fillStyle = "#b9605c"; // Player color
            context.fillRect(playerXOffset, playerYOffset, cellSize, cellSize);

            const endXOffset = maze.endY * cellSize + offsetX;
            const endYOffset = maze.endX * cellSize + offsetY;

            context.fillStyle = "#fd6266"; // Endpoint color
            context.fillRect(endXOffset, endYOffset, cellSize, cellSize);
        }


        function shouldAppearAsWall(x, y) {
            return Math.random() < wallProbability;
        }

        function movePlayer(dx, dy) {
            const newX = playerX + dx;
            const newY = playerY + dy;

            if (
                newX >= 0 &&
                newX < mazeSize * cellSize &&
                newY >= 0 &&
                newY < mazeSize * cellSize &&
                maze.maze[Math.floor(newY / cellSize)][Math.floor(newX / cellSize)] === 0
            ) {
                playerX = newX;
                playerY = newY;
                drawMaze();

                moveCount++;
                document.getElementById('moveCount').textContent = moveCount;

                if (playerX === maze.endY * cellSize && playerY === maze.endX * cellSize) {
                    clearInterval(stopwatchInterval);
                    finishMaze();
                    maze = generateMaze();
                    playerX = maze.startY * cellSize;
                    playerY = maze.startX * cellSize;
                    moveCount = 0;
                    document.getElementById('moveCount').textContent = moveCount;
                    startStopwatch();
                    drawMaze();
                }
            }
        }

        function finishMaze() {
            mazesFinishedCount++;
            document.getElementById('mazesFinishedCount').textContent = mazesFinishedCount;
        }

        function startStopwatch() {
            stopwatchSeconds = 0;
            clearInterval(stopwatchInterval);
            stopwatchInterval = setInterval(() => {
                stopwatchSeconds++;
                const minutes = Math.floor(stopwatchSeconds / 60);
                const seconds = stopwatchSeconds % 60;
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('stopwatch').textContent = timeString;
            }, 1000);
        }

        function updateWallProbability(value) {
            wallProbability = parseFloat(value);
            document.getElementById('wallProbabilityValue').textContent = wallProbability;
            drawMaze();
        }

        function initializeGame() {
            maze = generateMaze();
            playerX = maze.startY * cellSize;
            playerY = maze.startX * cellSize;
            drawMaze();
            startStopwatch();
        }

        initializeGame();

        document.addEventListener('keydown', function (event) {
            const key = event.key.toLowerCase();

            if (key === 'w') {
                movePlayer(0, -cellSize);
            } else if (key === 'a') {
                movePlayer(-cellSize, 0);
            } else if (key === 's') {
                movePlayer(0, cellSize);
            } else if (key === 'd') {
                movePlayer(cellSize, 0);
            }
        });
    </script>
</body>

</html>